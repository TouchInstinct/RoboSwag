package ru.touchin.roboswag.mvi_arch.core

import android.os.Parcelable
import androidx.annotation.CallSuper
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.onEach
import ru.touchin.roboswag.mvi_arch.marker.SideEffect
import ru.touchin.roboswag.mvi_arch.marker.StateChange
import ru.touchin.roboswag.mvi_arch.marker.ViewAction
import ru.touchin.roboswag.mvi_arch.marker.ViewState

/**
 *  Base [ViewModel] to use in MVI architecture.
 *
 *  @param NavArgs Type of arguments class of this screen.
 *  It must implement [NavArgs] interface provided by navigation library that is a part of Google Jetpack.
 *  An instance of this class is generated by [SafeArgs](https://developer.android.com/guide/navigation/navigation-pass-data#Safe-args)
 *  plugin according to related configuration file in navigation resource folder of your project.
 *
 *  @param State Type of view state class of this screen.
 *  It must implement [ViewState] interface. Usually it's a data class that presents full state of current screen's view.
 *  @see [ViewState] for more information.
 *
 *  @param Action Type of view actions class of this screen.
 *  It must implement [Action] interface. Usually it's a sealed class that contains classes and objects representing
 *  view actions of this view, e.g. button clicks, text changes, etc.
 *  @see [Action] for more information.
 *
 * @author Created by Max Bachinsky and Ivan Vlasov at Touch Instinct.
 */

abstract class MviStoreViewModel<NavArgs : Parcelable, Action : ViewAction, State : ViewState>(
        initialState: State,
        handle: SavedStateHandle
) : MviViewModel<NavArgs, Action, State>(initialState, handle) {

    private lateinit var store: ChildStore<*, *, *>

    protected fun <IChange : StateChange, IEffect : SideEffect, IState : ViewState> connectStore(
            store: Store<IChange, IEffect, IState>,
            mapAction: (Action) -> IChange?,
            mapState: (IState) -> State
    ) {
        this.store = ChildStore(store, mapAction)

        store
                .observeState()
                .map { mapState(it) }
                .onEach { this._state.postValue(it) }
                .launchIn(viewModelScope)

    }

    @CallSuper
    override fun dispatchAction(action: Action) {
        store.dispatchAction(action)
    }

    @CallSuper
    override fun onCleared() {
        super.onCleared()
        store.onCleared()
    }

    private inner class ChildStore<IChange : StateChange, IEffect : SideEffect, IState : ViewState>(
            val store: Store<IChange, IEffect, IState>,
            val changeMapper: (Action) -> IChange?
    ) {
        fun onCleared() {
            store.onCleared()
        }

        fun dispatchAction(action: Action) {
            changeMapper(action)?.let(store::changeState)
        }
    }

}
